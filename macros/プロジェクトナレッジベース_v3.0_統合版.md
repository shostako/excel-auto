# プロジェクトナレッジベース v3.0

## 1. 出力形式ルール

### 1.1 基本ルール
```
出力ルール:
  マクロ生成:
    形式: アーティファクト
    言語: VBA
    コメント: 日本語（詳細ヘッダー + 段階別コメント必須）
    完了メッセージ: 
      - ステータスバー: 推奨（処理状況の可視化）
      - MsgBox: エラー時のみ（正常終了時は禁止）
  
  M言語生成:
    形式: アーティファクト
    言語: Power Query M
    コメント: 日本語
  
  関数生成:
    形式: 通常メッセージ
    コメント: 日本語
    説明: コードの前後に使用方法を明記
```

### 1.2 重要な制約事項（Claude Code環境）

#### 参考マクロの読み込み（超重要！）
```bash
# 読む前に必ず実行
iconv -f SHIFT-JIS -t UTF-8 "参考マクロ/ファイル名.bas" | head -100
```

**理由**: 
- ユーザーがExcelからエクスポートしたファイルは**Shift-JIS**
- そのまま読むと文字化けして**列名を誤認識**する
- 過去の事故例：文字化けした列名で修正→本番で動作しない

**禁止事項**:
- 文字化けしたまま読み進めること
- 文字化けした内容を基に修正すること

### 1.3 VBAコメント標準（実用仕様）

#### 基本方針
- **実用性重視**: 実際に書けて、読みやすいコメント
- **柔軟性**: マクロの内容に応じて項目を調整
- **簡潔性**: 必要な情報を過不足なく記載

#### ヘッダーコメント標準形式

**必須項目（全マクロ共通）：**
```vba
' ========================================
' マクロ名: [マクロ名]
' 処理概要: [何をするマクロかを1行で]
' ソーステーブル: シート「[シート名]」テーブル「[テーブル名]」
' ターゲットテーブル: シート「[シート名]」テーブル「[テーブル名]」（該当する場合）
' ========================================
```

**任意項目（内容に応じて追加）：**
```vba
' 通称分類: [通称を扱う場合のみ]
' 転記データ: [転記処理がある場合のみ]
' 処理方式: [複雑な処理の場合のみ]
' 検証対象: [エラーチェック系の場合のみ]
' 例外処理: [特別なルールがある場合のみ]
```

#### 段階別コメント標準形式
```vba
' ============================================
' [処理内容の説明]：[詳細説明]
' ============================================
```

#### 実例1（転記マクロ）
```vba
' ========================================
' マクロ名: 転記_シート加工品番別
' 処理概要: 集計データを通称別テーブルへ転記し、通称別分析を可能にする
' ソーステーブル: シート「加工品番別」テーブル「_加工品番別a」
' ターゲットテーブル: シート「加工品番別」テーブル「_加工品番別b」
' 通称分類: アルヴェルF/R、ノアヴォクF/R、補給品の動的展開
' 転記データ: 実績、不良実績、稼働時間（稼働時間+段取時間の合計）
' 処理方式: 2段階集計（通称別+全体合計）による日付ベース転記
' ========================================
```

#### 実例2（エラーチェックマクロ）
```vba
' ========================================
' マクロ名: エラーチェック_基本版
' 処理概要: 生産管理システムデータの品質検証（Power Query処理前の事前チェック）
' ソーステーブル: シート「sysdata」テーブル「_sysdata」
' 検証対象: 作業区分、工程略称、機械コード、加工時間、ペア存在、時系列
' 例外処理: 内職工程は対象外、不良数量>0の加工完了は単独許可
' ========================================
```

#### 実例3（シンプルなマクロ）
```vba
' ========================================
' マクロ名: データクリア_月初
' 処理概要: 月初に不要な一時データをクリアする
' ターゲットテーブル: シート「temp」テーブル「_temp_data」
' ========================================
```

## 2. 致命的な失敗パターンと対策

### 2.1 画面ちらつき問題の真犯人（最重要）

#### 症状
- 「もたもた」「アニメーション」のような動き
- セルが一つずつ更新される様子が見える

#### 間違った診断（みんなが陥る罠）
「二重ループ（O(n×m)）が原因だ！」→ Dictionary実装

#### 真の原因
**Activateメソッドが諸悪の根源！**

```vba
' これが真犯人
ws.Activate  ' ← 画面がパタパタする元凶
Range("A1").Select  ' ← これも悪い
```

#### 正しい対処法
```vba
' 1. 最優先で追加
Application.ScreenUpdating = False
Application.Calculation = xlCalculationManual
Application.EnableEvents = False

' 2. Activateを完全排除
' ws.Activate ← 削除！

' 3. オブジェクト参照で直接操作
ws.Range("A1").Value = "データ"  ' Selectなし
```

### 2.2 CommandButton実行時の競合問題

#### 症状
- 個別実行は問題ないが、一括実行でちらつく
- 途中で画面更新が再開される

#### 原因
個別マクロが勝手に設定を変更している

#### 解決策
```vba
' CommandButtonのコード
Sub 一括実行()
    Application.ScreenUpdating = False
    
    Call マクロ1
    Call マクロ2
    Call マクロ3
    
    Application.ScreenUpdating = True
End Sub

' 個別マクロ（修正版）
Sub マクロ1()
    ' 個別マクロの最後で設定を戻さない！
    ' CommandButtonに任せる
    ' 処理のみ記述
End Sub
```

## 3. VBAマクロ基本テンプレート

### 3.1 標準テンプレート
```vba
Option Explicit

Sub OptimizedMacroTemplate()
    ' ========================================
    ' マクロ名: [マクロ名]（[用途・特徴]）
    ' 処理概要: [何をするマクロかを1行で]
    ' ========================================
    
    ' 最適化設定の保存
    Dim origScreenUpdating As Boolean
    Dim origCalculation As XlCalculation
    Dim origEnableEvents As Boolean
    Dim origDisplayAlerts As Boolean  ' 警告ダイアログ抑制用
    origScreenUpdating = Application.ScreenUpdating
    origCalculation = Application.Calculation
    origEnableEvents = Application.EnableEvents
    origDisplayAlerts = Application.DisplayAlerts
    
    ' 最適化設定
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.DisplayAlerts = False  ' 削除・クリア操作がある場合のみ
    
    ' エラーハンドリング設定
    On Error GoTo ErrorHandler
    
    ' ステータスバー初期化
    Application.StatusBar = "処理を開始します..."
    
    ' =================================
    ' 第1段階：基本設定とテーブル取得
    ' =================================
    
    ' =================================
    ' 第2段階：メイン処理
    ' 注意：Activateは絶対に使わない！
    ' =================================
    
    ' 処理完了のステータスバー表示
    Application.StatusBar = "処理が完了しました"
    Application.Wait Now + TimeValue("00:00:01")
    
    ' 正常終了時の処理
    GoTo Cleanup
    
ErrorHandler:
    ' エラー情報の取得
    Dim errNum As Long, errDesc As String
    errNum = Err.Number
    errDesc = Err.Description
    Err.Clear
    
    ' エラーメッセージの表示
    MsgBox "エラーが発生しました" & vbCrLf & _
           "エラー番号: " & errNum & vbCrLf & _
           "詳細: " & errDesc, vbCritical, "エラー"
    
Cleanup:
    ' 設定を元に戻す
    Application.StatusBar = False
    Application.ScreenUpdating = origScreenUpdating
    Application.Calculation = origCalculation
    Application.EnableEvents = origEnableEvents
    Application.DisplayAlerts = origDisplayAlerts
    
End Sub
```

### 3.2 軽量版テンプレート
```vba
Option Explicit

Sub LightweightMacroTemplate()
    ' 簡単な処理概要をここに記載
    
    Application.ScreenUpdating = False
    On Error GoTo ErrorHandler
    
    ' メイン処理（Activateは使わない）
    
    Application.ScreenUpdating = True
    Exit Sub
    
ErrorHandler:
    Application.ScreenUpdating = True
    MsgBox "エラー: " & Err.Description, vbCritical
End Sub
```

## 4. 最適化設定の使い分け

### 4.1 基本設定（ほぼ必須）
- `Application.ScreenUpdating = False` : 画面ちらつき防止（最重要）
- エラーハンドリング : 設定の確実な復元

### 4.2 条件付き設定（処理内容に応じて）
- `Application.Calculation = xlCalculationManual` : 計算式が多い場合
- `Application.EnableEvents = False` : イベント処理を一時停止
- `Application.DisplayAlerts = False` : 確認ダイアログ抑制

#### DisplayAlertsが必要な操作
- テーブル削除（`ListObjects.Delete`）
- 大量データクリア（`Range.Clear`）
- 行列削除操作
- セル範囲削除

#### DisplayAlertsが不要な操作
- データ読み取りのみ
- 計算処理のみ
- 新規作成のみ
- フォーマット変更のみ

## 5. ステータスバー管理

### 5.1 基本方針
- 長時間処理：必須
- 短時間処理：任意
- 処理完了表示：推奨

### 5.2 実装例
```vba
' 進捗表示（100行ごとに更新）
If i Mod 100 = 0 Then
    Application.StatusBar = "処理中... " & Format(i / totalRows, "0%")
End If

' 処理完了表示
Application.StatusBar = "処理が完了しました"
Application.Wait Now + TimeValue("00:00:01")
Application.StatusBar = False
```

## 6. テーブル操作のベストプラクティス

### 6.1 基本方針
**安全性 > パフォーマンス**

### 6.2 ListObject削除の推奨パターン

#### ❌ 間違った削除方法（非推奨）
```vba
' 不完全な削除 - 内部状態が不安定になりやすい
On Error Resume Next
If Not srcSheet.ListObjects(tableName) Is Nothing Then
    srcSheet.ListObjects(tableName).Delete  ' テーブル構造のみ削除
End If
On Error GoTo ErrorHandler
```

**問題点:**
- テーブル構造は削除されるが、セルの内容や書式が残る場合がある
- Excel内部の管理情報が中途半端な状態になりやすい
- 特に最後のテーブルやシート境界近くで処理が不安定になる
- `On Error Resume Next` でエラーを握りつぶすため、失敗に気づかない

#### ✅ 推奨される完全削除方法
```vba
' 完全削除パターン - 内部状態を確実にクリーンアップ
On Error Resume Next
Dim existingTable As ListObject
Set existingTable = Nothing
Set existingTable = srcSheet.ListObjects(tableName)
If Not existingTable Is Nothing Then
    existingTable.Unlist      ' テーブル形式を解除
    existingTable.Range.Clear ' セル範囲を完全クリア（動的範囲判定）
End If
Err.Clear                     ' エラー状態をリセット
On Error GoTo ErrorHandler
```

**利点:**
1. `Unlist`: ListObjectとしての機能を完全に停止
2. `Range.Clear`: セルの内容、書式、条件付き書式等を完全削除
3. **動的範囲判定**: `existingTable.Range` でExcelが管理する正確な範囲を自動取得
4. `Err.Clear`: エラー状態をリセットして次の処理を安全にする

### 6.3 範囲判定について
`existingTable.Range.Clear` は**動的に範囲を判定**する：
- **固定範囲ではない**: A1:E10のような決め打ちではなく、そのテーブルの実際のサイズに合わせる
- **Excel管理の情報を活用**: 人間が計算した範囲ではなく、Excelが記録している正確な占有範囲を使用
- **安全性**: 他のデータを巻き込む心配がない

### 6.4 新規テーブル作成の推奨パターン

#### 削除→新規作成（推奨）
```vba
' 既存テーブル完全削除
On Error Resume Next
Dim existingTable As ListObject
Set existingTable = Nothing
Set existingTable = destSheet.ListObjects("テーブル名")
If Not existingTable Is Nothing Then
    existingTable.Unlist
    existingTable.Range.Clear
End If
Err.Clear
On Error GoTo ErrorHandler

' 新規テーブル作成
Set destTable = destSheet.ListObjects.Add(xlSrcRange, tableRange, , xlYes)
destTable.Name = "テーブル名"
```

**メリット：**
- 列構造の不一致エラーが発生しない
- 確実に期待通りの構造になる
- シンプルで理解しやすい
- Excel内部状態が確実にクリーンな状態になる

#### テーブル再利用（非推奨）
**デメリット：**
- 既存テーブルの列構造が期待と異なる場合にエラー
- 手動変更により列名不一致の可能性
- 複雑な構造検証が必要
- 内部状態の不整合が蓄積しやすい

### 6.5 重要な教訓
- **Excel に任せる**: 人間が範囲計算するより、Excelの管理情報を信頼する
- **段階的削除**: `Unlist` → `Clear` → `Err.Clear` の順番を守る
- **エラーハンドリング**: `On Error Resume Next` で握りつぶすだけでなく、適切にリセットする
- **完全性重視**: 「動いているから良い」ではなく、「確実に削除されている」ことを保証する

## 7. 症状別診断パターン

### 7.1 画面がちらつく・もたもた動く
```
症状: セルが一つずつ更新される様子が見える
   ↓
原因1: Activateメソッドの使用（90%これ）
   ↓
対策: Activate完全削除 + ScreenUpdating = False
```

### 7.2 処理が異常に遅い
```
症状: 単純な処理なのに数分かかる
   ↓
チェック順序:
1. ScreenUpdating確認（まずこれ）
2. 計算モード確認
3. セル単位処理→配列処理
4. 無駄なループ削除
```

### 7.3 最適化の優先順位（黄金律）
1. **画面制御**（ScreenUpdating = False）
2. **Activate/Select排除**
3. **計算制御**（Calculation = Manual）
4. **配列処理**
5. **アルゴリズム改善**

## 8. エラーハンドリング

### 8.1 基本構造
```vba
On Error GoTo ErrorHandler
' 処理
GoTo Cleanup

ErrorHandler:
    ' エラー詳細の取得と表示
    Dim errNum As Long, errDesc As String
    errNum = Err.Number
    errDesc = Err.Description
    Err.Clear
    
    MsgBox "エラーが発生しました" & vbCrLf & _
           "エラー番号: " & errNum & vbCrLf & _
           "詳細: " & errDesc, vbCritical

Cleanup:
    ' 設定を確実に復元（最重要）
    Application.StatusBar = False
    Application.ScreenUpdating = origScreenUpdating
    ' その他の設定復元
End Sub
```

### 8.2 設定復元の保証
- エラー時も必ずCleanup処理を実行
- 最適化設定は確実に元に戻す
- エラー状態は適切にクリア（`Err.Clear`）

## 9. コーディング規約

### 9.1 必須事項
- 全モジュールの先頭に`Option Explicit`
- 変数は使用前に必ず宣言
- データ型を明示的に指定
- **実用的なヘッダーコメント**（必須項目＋内容に応じた任意項目）
- **段階別コメント**（`============================================`形式）

### 9.2 処理概要コメント（必須）
```vba
' シンプルなマクロの場合
Sub SimpleProcess()
    ' ========================================
    ' マクロ名: データ整形_CSV読込
    ' 処理概要: CSVファイルを読み込んでデータを整形する
    ' ターゲットテーブル: シート「import」テーブル「_csv_data」
    ' ========================================

' 複雑なマクロの場合
Sub ComplexProcess()
    ' ========================================
    ' マクロ名: 集計処理_多シート統合
    ' 処理概要: 複数のシートからデータを収集して条件に基づいて集計を行う
    ' ソーステーブル: シート「Sheet1,Sheet2」テーブル「_source_data」
    ' ターゲットテーブル: シート「Result」テーブル「集計結果」
    ' 処理方式: Dictionary集計後、日付ベース転記
    ' ========================================
```

### 9.3 命名規則
- 変数: camelCase（例: `totalCount`）
- 定数: UPPER_SNAKE_CASE（例: `MAX_RETRY_COUNT`）
- プロシージャ: PascalCase（例: `ProcessData`）

## 10. MCPサーバーのthinkツール活用

### 10.1 活用場面
```
thinkツール活用:
  必須使用場面:
    - 複雑なアルゴリズム設計
    - パフォーマンス問題の分析
    - 複数の実装方法の比較検討
    - デバッグ戦略の立案
    - テーブル操作の最適化設計
```

### 10.2 思考記録管理
- `think`: 思考プロセスの記録
- `get_thoughts`: 記録した思考の取得
- `clear_thoughts`: 思考記録のリセット
- `get_thought_stats`: 統計情報の確認

## 11. メッセージ表示ガイドライン

### 11.1 ステータスバー（推奨）
- 処理の開始・進捗・完了の表示
- リアルタイムな状態表示
- ユーザーへの視覚的フィードバック

### 11.2 MsgBox（制限付き使用）
**使用場面:**
- エラー発生時の通知
- ユーザーの確認が必要な場合
- 重要な警告の表示

**禁止事項:**
- 正常終了時の「完了しました」メッセージ
- 進捗表示（ステータスバーを使用）

## 12. パフォーマンス最適化

### 12.1 データ処理の最適化
- 配列を使用してセルアクセス回数を減らす
- Rangeオブジェクトの一括操作を活用
- 不要な選択や移動を避ける
- **Activateメソッドの完全排除**（最重要）

### 12.2 進捗更新の最適化
```vba
' 100行ごとに進捗更新（頻繁すぎると遅くなる）
If i Mod 100 = 0 Then
    Application.StatusBar = "処理中... " & Format(i / totalRows, "0%")
End If
```

### 12.3 テーブル操作の最適化
- 完全削除パターンによる内部状態の安定化
- 動的範囲判定による安全な範囲指定
- エラー状態の適切なリセット

## 13. 文字エンコーディング管理（Claude Code環境）

### 13.1 読み込み時の必須手順
```bash
# 参考マクロファイル読み込み前に必ず実行
iconv -f SHIFT-JIS -t UTF-8 "参考マクロ/ファイル名.bas" | head -100

# 文字化け確認用
file "参考マクロ/ファイル名.bas"
```

### 13.2 エンコーディング管理
- **参考マクロ**: Shift-JIS（Excelエクスポート）
- **src/**: UTF-8（Claude編集用）
- **macros/**: Shift-JIS（Excel取り込み用）

### 13.3 変換スクリプト
```bash
# 基本的な使用方法
./scripts/bas2sjis src/マクロ名.bas

# 変換結果の確認
ls -la macros/
```

## 14. 重要事項チェックリスト

### 必須項目
- [ ] `Option Explicit`の記述
- [ ] **実用的なヘッダーコメント**（必須項目＋内容に応じた任意項目）
- [ ] **段階別コメント**（`============================================`形式）
- [ ] **Activateメソッドの完全排除**（最重要）
- [ ] エラーハンドリングの実装
- [ ] 最適化設定の復元処理
- [ ] ステータスバーのクリア処理
- [ ] ListObject削除時の完全削除パターン使用
- [ ] 参考マクロは必ずiconvで変換してから読む（Claude Code）

### 条件付き項目
- [ ] `DisplayAlerts = False`（削除・クリア操作がある場合）
- [ ] 進捗表示（長時間処理の場合）
- [ ] 完了表示（ステータスバー）
- [ ] パフォーマンス測定（必要に応じて）

### 禁止事項
- [ ] **Activateメソッドの使用**（最重要）
- [ ] 設定を元に戻さない処理
- [ ] MsgBoxによる正常終了メッセージ
- [ ] 過度に頻繁な画面更新
- [ ] 不完全なListObject削除（`Delete`のみ）
- [ ] エラー状態の放置（`Err.Clear`忘れ）
- [ ] 文字化けしたファイルの内容を基にした修正（Claude Code）

## 15. トラブルシューティング

### 15.1 ListObject関連のよくある問題
**症状:** テーブル削除後も範囲に書式が残る
**原因:** `Delete`のみで完全削除していない
**対策:** `Unlist` → `Range.Clear` → `Err.Clear` の完全削除パターンを使用

**症状:** 連続でテーブル処理するとエラーが発生
**原因:** Excel内部の管理状態が不安定
**対策:** 各処理後に`Err.Clear`でエラー状態をリセット

**症状:** シート末尾のテーブル処理が不安定
**原因:** 境界近くでの範囲計算ミス
**対策:** `existingTable.Range`で動的範囲判定を使用

### 15.2 デバッグのコツ
- テーブル操作は一つずつステップ実行で確認
- `Range.Address`でテーブル範囲を確認
- `ListObjects.Count`でテーブル数の変化を監視

## 16. 実戦的格言（失敗から生まれた教訓）

> **「Activateを見たら即削除」**
> 
> **「賢い解決策より、正しい解決策を選べ」**
> 
> **「Dictionaryより先にScreenUpdating」**
> 
> **「文字化けは列名誤認識の元凶」**
> 
> **「症状から正しく原因を推測すること」**
> 
> **「コメントは実装より先に、詳細は省略より優先」**

---

## 注意事項

- このナレッジは実際の失敗から生まれた実戦的なものです
- 理論より実践、完璧より実用性を重視します
- 同じ失敗を繰り返さないことが最優先です
- **特に画面ちらつき問題は、Activateが真犯人だと覚えておいてください**
- Claude Code環境では文字エンコーディング管理が特に重要です

*「過去の失敗を無視して、毎回同じ失敗を繰り返してる」 という状況を避けるためのナレッジです。*