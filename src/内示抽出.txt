let
    // ========== 共通処理を関数化 ==========
    処理関数 = (入力テーブル as table) as table =>
    let
        // 1. Column1を削除
        列1削除 = Table.RemoveColumns(入力テーブル, {"Column1"}),

        // 2. 1行目と2行目をヘッダーとして取得
        ヘッダー行1 = Table.ToRows(Table.FirstN(列1削除, 1)){0},
        ヘッダー行2 = Table.ToRows(Table.Skip(列1削除, 1)){0},

        // 3. データ部分（3行目以降）
        データ部分 = Table.Skip(列1削除, 2),

        // 4. インデックスを追加してペア番号を計算
        インデックス追加 = Table.AddIndexColumn(データ部分, "Index", 0, 1),
        ペア番号追加 = Table.AddColumn(インデックス追加, "ペア", each Number.IntegerDivide([Index], 2)),

        // 5. 奇数行と偶数行に分離
        奇数行 = Table.SelectRows(ペア番号追加, each Number.Mod([Index], 2) = 0),
        偶数行 = Table.SelectRows(ペア番号追加, each Number.Mod([Index], 2) = 1),

        // 6. 元の列名リスト
        元の列名 = List.RemoveItems(Table.ColumnNames(奇数行), {"Index", "ペア"}),

        // 7. 奇数行の列に"_奇数"、偶数行の列に"_偶数"を付けてリネーム
        奇数行リネーム = Table.RenameColumns(奇数行,
            List.Transform(元の列名, each {_, _ & "_奇数"})),
        偶数行リネーム = Table.RenameColumns(偶数行,
            List.Transform(元の列名, each {_, _ & "_偶数"})),

        // 8. ペア番号でマージ
        マージ = Table.NestedJoin(奇数行リネーム, {"ペア"}, 偶数行リネーム, {"ペア"}, "偶数行データ", JoinKind.Inner),

        // 9. 偶数行の列を展開
        偶数列名 = List.Transform(元の列名, each _ & "_偶数"),
        展開 = Table.ExpandTableColumn(マージ, "偶数行データ", 偶数列名),

        // 10. Index, ペア列を削除
        不要列削除 = Table.RemoveColumns(展開, {"Index", "ペア"}),

        // 11. ヘッダーをリネーム
        奇数列リネーム = List.Zip({
            List.Transform(元の列名, each _ & "_奇数"),
            ヘッダー行1
        }),
        偶数列リネーム = List.Zip({
            List.Transform(元の列名, each _ & "_偶数"),
            ヘッダー行2
        }),
        全リネームペア = List.Combine({奇数列リネーム, 偶数列リネーム}),
        リネームペア除外null = List.Select(全リネームペア, each _{1} <> null and _{1} <> ""),
        最終リネーム = Table.RenameColumns(不要列削除, リネームペア除外null),

        // 12. 必要な列のみ選択
        削除された他の列 = Table.SelectColumns(最終リネーム,
            {"品番", "納入単位", "当月注文数", "翌月内示数", "翌々月内示数",
             "1日", "2日", "3日", "4日", "5日", "6日", "7日", "8日", "9日", "10日",
             "11日", "12日", "13日", "14日", "15日", "16日", "17日", "18日", "19日", "20日",
             "21日", "22日", "23日", "24日", "25日", "26日", "27日", "28日", "29日", "30日", "31日"}),

        // 13. 列順を整理
        並べ替えられた列 = Table.ReorderColumns(削除された他の列,
            {"品番",
             "1日", "2日", "3日", "4日", "5日", "6日", "7日", "8日", "9日", "10日",
             "11日", "12日", "13日", "14日", "15日", "16日", "17日", "18日", "19日", "20日",
             "21日", "22日", "23日", "24日", "25日", "26日", "27日", "28日", "29日", "30日", "31日",
             "納入単位", "翌月内示数", "翌々月内示数", "当月注文数"}),

        // 14. 列名変更（翌月内示数→翌月、翌々月内示数→翌々月、当月注文数→計）
        列名変更 = Table.RenameColumns(並べ替えられた列, {
            {"翌月内示数", "翌月"},
            {"翌々月内示数", "翌々月"},
            {"当月注文数", "計"}
        }),

        // 15. データ型の変換（品番以外を数値型に）
        数値列リスト = List.RemoveItems(Table.ColumnNames(列名変更), {"品番"}),
        型変換リスト = List.Transform(数値列リスト, each {_, Int64.Type}),
        型変換 = Table.TransformColumnTypes(列名変更,
            List.Combine({型変換リスト, {{"品番", type text}}})),

        // 16. 日付列のリネーム（「1日」→「1」、「2日」→「2」...「31日」→「31」）
        日付列リネームペア = List.Transform({1..31}, each {"" & Text.From(_) & "日", Text.From(_)}),
        日付列リネーム = Table.RenameColumns(型変換, 日付列リネームペア)
    in
        日付列リネーム,

    // ========== メイン処理 ==========
    // PDFを読み込み
    ソース = Pdf.Tables(File.Contents("Z:\全社共有\生産管理課\生産管理\受注\【内示表】ハモコ・ジャパン_251022.pdf"), [Implementation="1.3"]),

    // 【第1層防御】各ページの2番目のテーブル（Table002, Table004, Table006...）を抽出
    // 構造が正しいテーブルのみを選択（列数30以上、行数2以上）
    対象テーブル = Table.SelectRows(ソース, each
        let
            IdText = [Id],
            数字部分 = Text.AfterDelimiter(IdText, "Table"),
            数値 = try Number.From(数字部分) otherwise -1,
            テーブル構造 = [Data],
            列数 = try Table.ColumnCount(テーブル構造) otherwise 0,
            行数 = try Table.RowCount(テーブル構造) otherwise 0
        in
            数値 > 0 and
            Number.Mod(数値, 2) = 0 and
            列数 >= 30 and  // 正常なテーブルは32列
            行数 >= 2        // 最低2行
    ),

    // 【第2層防御】各テーブルに処理関数を適用（エラー時はnull）
    処理済みテーブルリスト = List.Transform(対象テーブル[Data], each
        try 処理関数(_) otherwise null
    ),

    // 【第3層防御】nullを除外して有効なテーブルのみを残す
    有効テーブルのみ = List.Select(処理済みテーブルリスト, each _ <> null),

    // 全テーブルを縦に連結
    統合結果 = Table.Combine(有効テーブルのみ)
in
    統合結果
